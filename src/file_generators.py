from abc import ABC, abstractmethod
from dataclasses import dataclass, field
import textwrap
from typing import List
from pathlib import Path
from SubdirReplacement import SubdirReplacement
from PathSearchAndReplace import PathSearchAndReplace


class FileGenerator(ABC):
    def to_file(self, file: Path) -> None:
        file.parent.mkdir(parents=True, exist_ok=True)
        with open(file, "w") as f:
            f.write(self.to_string())

    @abstractmethod
    def to_string(self) -> str:
        """Dump content to string"""


@dataclass
class VariantConfigCMakeGenerator(FileGenerator):
    compiler_flags: str
    linker_file: str
    link_flags: str
    cmake_toolchain_file: str

    def to_string(self) -> str:
        return textwrap.dedent(
            f"""\
        set(VARIANT_C_FLAGS {self.compiler_flags})
        set(VARIANT_LINKER_FILE {self.linker_file})
        set(VARIANT_LINK_FLAGS {self.link_flags})
        set(CMAKE_TOOLCHAIN_FILE {self.cmake_toolchain_file} CACHE PATH "toolchain file")
        """
        )


@dataclass
class VariantPartsCMakeGenerator(FileGenerator):
    include_paths: List[Path]
    third_party_libs: List[Path]
    subdir_extra_replacements: List[SubdirReplacement] = field(default_factory=list)

    def to_string(self) -> str:
        return "\n".join(
            [
                "# Generated by Transformer",
                self.cmake_includes(),
                "",
                f"spl_add_component(legacy)",
                self.cmake_link_libraries(),
                "",
            ]
        )

    def cmake_includes(self) -> str:
        return "\n".join(
            [f"spl_add_include({self.replace(inc)})" for inc in self.include_paths]
        )

    def replace(self, path: Path) -> str:
        replacer = PathSearchAndReplace(
            self.subdir_extra_replacements
            + [SubdirReplacement("/", "${PROJECT_SOURCE_DIR}/legacy/${VARIANT}/src")]
        )
        return replacer.replace_path(path).as_posix()

    def cmake_link_libraries(self) -> str:
        return "\n".join(
            [
                "target_link_libraries(${LINK_TARGET_NAME} ${CMAKE_CURRENT_LIST_DIR}/Lib/"
                + lib.as_posix()
                + ")"
                for lib in self.third_party_libs
            ]
        )


@dataclass
class LegacyPartsCMakeGenerator(FileGenerator):
    sources: List[Path]
    subdir_extra_replacements: List[SubdirReplacement] = field(default_factory=list)

    def to_string(self) -> str:
        return "\n".join(["# Generated by Transformer", self.cmake_sources(), ""])

    def cmake_sources(self) -> str:
        return "\n".join(
            [f"spl_add_source({self.replace(source)})" for source in self.sources]
        )

    def replace(self, path: Path) -> str:
        replacer = PathSearchAndReplace(
            self.subdir_extra_replacements + [SubdirReplacement("/", "src")]
        )
        return replacer.replace_path(path).as_posix()


class LegacyCMakeListsGenerator(FileGenerator):
    def __init__(self) -> None:
        super().__init__()

    def to_string(self) -> str:
        return textwrap.dedent(
            """\
        # Generated by Transformer
        include(${VARIANT}/parts.cmake)
        spl_create_component()
        """
        )
